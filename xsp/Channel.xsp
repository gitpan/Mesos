%module{Mesos};
#include <MesosChannel.hpp>
#include <XS/MesosUtils.hpp>


%name{Mesos::Channel} class mesos::perl::MesosChannel
{

%{

static void
DESTROY(SV* self)
    PPCODE:
        // make sure the c++ destructor only gets called once
        //  (both the blessed glob and the tied hash will call DESTROY)
        if (!SvROK(self) || (SvTYPE(SvRV(self)) != SVt_PVGV))
            XSRETURN_YES;
        SV* glob = SvRV(self);
        MAGIC *tie_magic = mg_find(MUTABLE_SV(GvIOp(glob)), PERL_MAGIC_tiedscalar);
        SV* tied_hash = SvRV(tie_magic->mg_obj);
        MAGIC* ext_magic = mg_find(tied_hash, PERL_MAGIC_ext);
        mesos::perl::MesosChannel* channel = (mesos::perl::MesosChannel*) ext_magic->mg_ptr;
        delete channel;
        XSRETURN_YES;

static void
xs_init(SV* self)
    PPCODE:
        if (SvROK(self) && SvTYPE(SvRV(self)) == SVt_PVHV) {
            mesos::perl::MesosChannel* channel = new mesos::perl::MesosChannel;
            sv_magic(SvRV(self), Nullsv, PERL_MAGIC_ext,
                             (const char*) channel, 0);
        }

mesos::perl::MesosCommand
mesos::perl::MesosChannel::recv()
    CODE:
        if (!THIS->pending_->size()) {
            if (GIMME_V == G_ARRAY) {
                XSRETURN_EMPTY;
            } else {
                XSRETURN_UNDEF;
            }
        }
        RETVAL = THIS->recv();
    OUTPUT:
        RETVAL

void
mesos::perl::MesosChannel::send(mesos::perl::MesosCommand command)
    PPCODE:
        THIS->send(command);
        XSRETURN_YES;

int
mesos::perl::MesosChannel::fd()
    CODE:
        RETVAL = fileno(THIS->in_);
    OUTPUT:
        RETVAL

%}

};
